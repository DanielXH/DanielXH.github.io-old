<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>计算机基础与数据存储、运算 | DanielXH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
      <link rel="icon" href="/DanielXH-logo.png">
    

    <link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="/js/google-code-prettify/code-color.css">

  </head>

  <body>

<header>
	<a id="logo" href="/" title="DanielXH">
	<img src="/DanielXH-logo.png" alt="DanielXH"></a>
	
	
		<!--搜索栏-->
		<i class="js-toggle-search iconfont icon-search"></i>


<form class="js-search search-form search-form--modal" method="get" action="http://gushi.li" role="search">
	<div class="search-form__inner">
		<div>
			<i class="iconfont icon-search"></i>
			<input class="text-input" placeholder="Enter Key..." type="search">
		</div>
	</div>
</form>
	

	
		<!--侧边导航栏-->
		<a id="nav-toggle" href="#"><span></span></a>

<nav>
	<div class="menu-top-container">
		<ul id="menu-top" class="menu">
			
				
				<li class="current-menu-item">
					<a href="javascript:;" target="_blank">Weibo</a>
				</li>
			
		</ul>
	</div>
</nav>
	

</header>
<div class="m-header ">
	<section id="hero1" class="hero">
		<div class="inner">
		</div>
	</section>
	
		<figure class="top-image" data-enable=true></figure>
	
</div>

<!--文章列表-->
<div class="wrapper">
  
    <!--文章-->
<article>
	
  
    <h1 class="post-title" itemprop="name">
      计算机基础与数据存储、运算
    </h1>
  

	<div class='post-body mb'>
		<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-图灵模型"><a href="#1-1-图灵模型" class="headerlink" title="1.1 图灵模型"></a>1.1 图灵模型</h2><p>图灵机：设想所有的计算都可能在一种特殊的机器上执行。</p>
<h3 id="1-1-1-数据处理器"><a href="#1-1-1-数据处理器" class="headerlink" title="1.1.1 数据处理器"></a>1.1.1 数据处理器</h3><p>数据处理器：一个接收输入数据、处理数据并产生输出数据的黑盒。</p>
<center>输入数据 → 计算机 → 输出数据</center>

<h3 id="1-1-2-可编程数据处理器"><a href="#1-1-2-可编程数据处理器" class="headerlink" title="1.1.2 可编程数据处理器"></a>1.1.2 可编程数据处理器</h3><p>图灵模型是一个使用于通用计算机的更好的模型。该模型添加了一个额外的元素——程序到不同的计算机中。<br><strong>程序</strong>是用来告诉计算机对数据进行处理的指令集合。</p>
<center>输出数据 → 计算机 （程序） → 输入数据</center>

<p>输出数据是依赖两方面因素的结合作用：输入数据和程序。</p>
<h3 id="1-1-3-通用图灵机"><a href="#1-1-3-通用图灵机" class="headerlink" title="1.1.3 通用图灵机"></a>1.1.3 通用图灵机</h3><p>通用图灵机是对现代计算机的首次描述，该机器只要提供合适的程序就能做任何运算。</p>
<hr>
<h2 id="1-2-冯·诺伊曼模型"><a href="#1-2-冯·诺伊曼模型" class="headerlink" title="1.2 冯·诺伊曼模型"></a>1.2 冯·诺伊曼模型</h2><p>基于通用图灵计算机建造的计算机都是在存储器中存储数据。冯·诺依曼提出，鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。</p>
<h3 id="1-2-1-4个子系统"><a href="#1-2-1-4个子系统" class="headerlink" title="1.2.1 4个子系统"></a>1.2.1 4个子系统</h3><p>基于冯·诺依曼模型建造的计算机分为4个子系统：存储器、算术逻辑单元、控制单元、输入/输出单元。</p>
<ol>
<li>存储器：用来存储的区域。在计算机的处理过程中存储器用来存储数据和程序。</li>
<li>算术逻辑单元（ALU）：用来进行计算和逻辑运算的地方。</li>
<li>控制单元：对储存器、算术逻辑单元、输入/输出等子系统进行控制操作的单元。</li>
<li>输入/输出：输入子系统负责从计算机外部接收输入数据和程序；输出子系统负责讲计算机的处理结果输出到计算机外部。输入/输出子系统的定义相当广泛，它们还包含辅助储存设备。</li>
</ol>
<h3 id="1-2-2-存储的程序概念"><a href="#1-2-2-存储的程序概念" class="headerlink" title="1.2.2 存储的程序概念"></a>1.2.2 存储的程序概念</h3><p>现代计算机的存储单元主要用来存储程序及其响应数据。这意味着数据和程序应该具有相同的格式，因它们都储存在存储器中，实际上它们都以位模式（0和1序列）存储在内存中的。</p>
<h3 id="1-2-3-指令的顺序执行"><a href="#1-2-3-指令的顺序执行" class="headerlink" title="1.2.3 指令的顺序执行"></a>1.2.3 指令的顺序执行</h3><p>冯·诺依曼模型中的一段程序是由一组数量有限的指令组成。按照这个模型，控制单元从内存中提取一条指令，解释指令，接着执行指令。指令的顺序执行是基于冯·诺依曼模型的计算机的初始条件。当今的计算机以最高效的顺序来执行程序。</p>
<hr>
<h2 id="1-3-计算机的组成"><a href="#1-3-计算机的组成" class="headerlink" title="1.3 计算机的组成"></a>1.3 计算机的组成</h2><p>可以认为计算机由3大部分组成：计算机硬件、数据、计算机软件。</p>
<h3 id="1-3-1-计算机硬件"><a href="#1-3-1-计算机硬件" class="headerlink" title="1.3.1 计算机硬件"></a>1.3.1 计算机硬件</h3><p>当今计算机硬件基于冯·诺依曼模型，包含四部分。</p>
<h3 id="1-3-2-数据"><a href="#1-3-2-数据" class="headerlink" title="1.3.2 数据"></a>1.3.2 数据</h3><p>冯·诺依曼模型讲一台计算机定义为一台数据处理机。</p>
<ol>
<li>存储数据：冯·诺依曼模型没有定义数据应该如何存储在计算机中。</li>
<li>组织数据：在将数据存储到计算机中之前，有效地将数据组织成不同的实体和格式，数据被组织成许多小的单元，再由这些小的单元组成更大的单元。</li>
</ol>
<h3 id="1-3-3-计算机软件"><a href="#1-3-3-计算机软件" class="headerlink" title="1.3.3 计算机软件"></a>1.3.3 计算机软件</h3><p>编程在早期的计算机中体现为对系统开关的开闭合和配线的改变。</p>
<ol>
<li>必须存储程序：内存中不仅仅需要存储数据，还要存储程序。</li>
<li>指令的序列：程序必须是有序的指令集，每一条指令操作一个或者多个数据项。</li>
<li>算法：对于一些不同的问题，程序员首先应该以循序渐进的方式来解决问题，接着尽量找到合适的指令（指令序列）来解决问题，这种按步骤解决问题的方法就是所谓的算法。</li>
<li>语言：计算机语言</li>
<li>软件工程：指结构化程序的设计和编写。</li>
<li>操作系统：在计算机发展演变过程中发现，有一系列指令对所有程序来说是公用的。如果这些指令只编写一次就可以用于所有程序，那么效率将会大大提高，因此出现了操作系统。计算机操作系统最初是为程序访问计算机部件提供方便的一种管理程序。</li>
</ol>
<hr>
<h2 id="1-4-历史"><a href="#1-4-历史" class="headerlink" title="1.4 历史"></a>1.4 历史</h2><ol>
<li>机械计算机器（1930年以前）</li>
<li>电子计算机的诞生（1930~1950年）</li>
<li>计算机的诞生（1950年至今）</li>
</ol>
<hr>
<hr>
<h1 id="第2章-数字系统"><a href="#第2章-数字系统" class="headerlink" title="第2章 数字系统"></a>第2章 数字系统</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p>数字系统（或数码系统）定义了如何用独特的符号来表示一个数字。<br>可分为两类：位置化系统、非位置化系统。</p>
<hr>
<h2 id="2-2-位置化数字系统"><a href="#2-2-位置化数字系统" class="headerlink" title="2.2 位置化数字系统"></a>2.2 位置化数字系统</h2><p>位置化数字系统中，在数字中符号所占据的位置决定了其表示的值。在该系统中，数字这样表示：</p>
<center>\(\pm (S<em>{k-1}\cdot \cdot \cdot S</em>{2}S<em>{1}S</em>{0}.S<em>{-1}S</em>{-2}\cdot \cdot \cdot S<em>{-l})</em>{b}\)  —①</center>

<p>它的值是：</p>
<center>\(n=\pm S<em>{k-1}\times b^{k-1}+···+S</em>{1}\times b^{1}+S<em>{0}\times b^{0}+S</em>{-1}\times b^{-1}+S<em>{-2}\times b^{-2}+···+S</em>{-l}\times b^{-l}\) —②</center>

<p>其中，S是一套符号集，b是底（或基数），它等于S符号集中的符号总数，其中\(S_{i}\)只该符号的位置是\(i\)，±符号表示该数字可正可负。</p>
<p>位置化数字系统就是进位制。以87.53举例，公式①相当于直接写成87.53的形式；而公式②就是写成：<br>$$87.53=+8\times 10^{1}+7\times 10^{0} + 5\times 10^{-1}+3\times 10^{-2}$$<br>S就是位置上的数字，k就是第几位， Sk-1就是第k-1位上的数字，b就是几进制。</p>
<h3 id="2-2-1-十进制系统（以10为底）"><a href="#2-2-1-十进制系统（以10为底）" class="headerlink" title="2.2.1 十进制系统（以10为底）"></a>2.2.1 十进制系统（以10为底）</h3><p>十进制系统，底b=10，符号集是S=｛0，1，2，3，4，5，6，7，8，9｝，该系统中的符号常被称为<strong>十进制数码</strong>或<strong>数码</strong>。<br><strong>计算机存储正负数的方式不同。</strong></p>
<h4 id="1-整数"><a href="#1-整数" class="headerlink" title="1.整数"></a>1.整数</h4><p>整数表示为：<br>$$\pm S<em>{k-1}\cdot \cdot \cdot S</em>{2}S<em>{1}S</em>{0}$$<br>其值计算为：<br>$$n=\pm S<em>{k-1}\times 10^{k-1}+···+S</em>{1}\times b^{1}\times b^{0}$$<br>可以用数码k表示十进制整数的最大值，最大值为\(N<em>{max}=10^{k}-1\)。如k=5，那么这个最大值为\(N</em>{max}=10^{5}-1=99999\)。</p>
<h4 id="2-实数"><a href="#2-实数" class="headerlink" title="2.实数"></a>2.实数</h4><p>$$n=\pm S<em>{k-1}\times b^{k-1}+···+S</em>{1}\times b^{1}+S<em>{0}\times b^{0}+S</em>{-1}\times b^{-1}+S<em>{-2}\times b^{-2}+···+S</em>{-l}\times b^{-l}$$<br>k是整数部分数码的数量，l是小数部分数码的数量。</p>
<h3 id="2-2-2-二进制系统（以2为底）"><a href="#2-2-2-二进制系统（以2为底）" class="headerlink" title="2.2.2 二进制系统（以2为底）"></a>2.2.2 二进制系统（以2为底）</h3><p>底b=2，S=｛0，1｝。该系统中的符号常被称为<strong>二进制数码</strong>或<strong>位</strong>（位数码）。<br>数码k表示的二进制整数的最大值是\(N_{max}=2^{k}-1\)，如k=5，那么这个最大值就是31。</p>
<h3 id="2-2-3-十六进制系统（以16为底）"><a href="#2-2-3-十六进制系统（以16为底）" class="headerlink" title="2.2.3 十六进制系统（以16为底）"></a>2.2.3 十六进制系统（以16为底）</h3><p>底b=16，字符集S=｛0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F｝。<br>符号A，B，C，D，E，F分别等于10，11，12，13，14，15。该系统中的符号称为<strong>十六进制数码</strong>。</p>
<h3 id="2-2-4-八进制系统（以8为底）"><a href="#2-2-4-八进制系统（以8为底）" class="headerlink" title="2.2.4 八进制系统（以8为底）"></a>2.2.4 八进制系统（以8为底）</h3><p>与以上进制系统同理。</p>
<h3 id="2-2-5-4种位置化系统小结"><a href="#2-2-5-4种位置化系统小结" class="headerlink" title="2.2.5 4种位置化系统小结"></a>2.2.5 4种位置化系统小结</h3><table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
<th>八进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>10</td>
<td>8</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>11</td>
<td>9</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>12</td>
<td>A</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
<td>13</td>
<td>B</td>
</tr>
<tr>
<td>12</td>
<td>1100</td>
<td>14</td>
<td>C</td>
</tr>
<tr>
<td>13</td>
<td>1101</td>
<td>15</td>
<td>D</td>
</tr>
<tr>
<td>14</td>
<td>1110</td>
<td>16</td>
<td>E</td>
</tr>
<tr>
<td>15</td>
<td>1111</td>
<td>17</td>
<td>F</td>
</tr>
</tbody>
</table>
<h3 id="2-2-6-转换"><a href="#2-2-6-转换" class="headerlink" title="2.2.6 转换"></a>2.2.6 转换</h3><h4 id="1-其他进制到十进制的转换"><a href="#1-其他进制到十进制的转换" class="headerlink" title="1. 其他进制到十进制的转换"></a>1. 其他进制到十进制的转换</h4><p>$$N=\pm (S<em>{k-1}\cdot \cdot \cdot S</em>{2}S<em>{1}S</em>{0}.S<em>{-1}S</em>{-2}\cdot \cdot \cdot S<em>{-l})</em>{b}$$<br>直接按照以上公式求解，N即为十进制数字。</p>
<h4 id="2-十进制到其他进制的转换"><a href="#2-十进制到其他进制的转换" class="headerlink" title="2. 十进制到其他进制的转换"></a>2. 十进制到其他进制的转换</h4><p>（1）转换整数部分<br>举例：将十进制数35转换为二进制数。<br>从这个十进制数开始，一边连续寻找除以2得到的商和余数，一边左移。结果是\((100011)_{2}\)。</p>
<pre>
0 ←  1 ←  2 ←  4 ←  8 ← 17 ← 35   十进制
     ↓    ↓    ↓    ↓    ↓    ↓
     1    0    0    0    1    1   二进制
</pre>

<p>（2）转换小数部分<br>举例：将0.634转换成八进制且精确到小数4位。<br>从这个十进制数开始，连续乘8，并记录结果的整数和小数部分，。小数部分移到右边，整数部分写在每次运算的下面。当小数部分为0，或达到足够的位数时结束。结果是\(0.634=(0.5044)_{8}\)。</p>
<pre>
十进制   0.634 → 0.072 → 0.576 → 0.608 → 0.864
           ↓       ↓       ↓       ↓        
八进制      5       0       4       4
</pre>

<h4 id="3-二进制-十六进制的转换"><a href="#3-二进制-十六进制的转换" class="headerlink" title="3. 二进制-十六进制的转换"></a>3. 二进制-十六进制的转换</h4><p>可以轻松将数字在二进制和十六进制之间转换。因为在这两个进制之间存在一种关系：二进制的4位恰好是十六进制中的1位。<br>举例：将二进制数 \((10011100010)<em> {2}\) 转换为十六进制数字。<br>先将二进制数从右边开始排为4位一组的形式：100 1110 0010。再根据上表对照每组的值等量转换得到十六进制数字\((4E2)</em> {16}\)。</p>
<h4 id="4-二进制-八进制的转换"><a href="#4-二进制-八进制的转换" class="headerlink" title="4. 二进制-八进制的转换"></a>4. 二进制-八进制的转换</h4><p>二进制的3位恰好是八进制中的1位。因此转换方式与二进制-十六进制的转换方式相同。</p>
<h4 id="5-八进制-十六进制的转换"><a href="#5-八进制-十六进制的转换" class="headerlink" title="5. 八进制-十六进制的转换"></a>5. 八进制-十六进制的转换</h4><p>使用二进制系统作为中介系统进行转换。</p>
<hr>
<h2 id="2-3-非位置化数字系统"><a href="#2-3-非位置化数字系统" class="headerlink" title="2.3 非位置化数字系统"></a>2.3 非位置化数字系统</h2><p>非位置化数字系统并不用在计算机中。<br>非位置化数字系统仍然使用有限的数字符号，每个符号有一个值，但是符号所占用的位置通常与其值无关——每个符号的值是固定的。为求出该数字的值，把所有符号表示的值相加即可。该系统数字表示为：<br>$$S<em>{k-1}\cdot \cdot \cdot S</em>{2}S<em>{1}S</em>{0}.S<em>{-1}S</em>{-2}\cdot \cdot \cdot S<em>{-l}$$<br>其值为：<br>$$n=\pm S</em>{k-1}+···+S<em>{1}+S</em>{0}+S<em>{-1}+S</em>{-2}+···+S_{-l}$$</p>
<p>罗马数字是非位置化数字系统的一个好例子。该数字系统有一套符号S=｛I，V，X，L，C，D，M｝。<br>|符号|I   |V   |X   |L   |C   |D   |M   |<br>|–  |<br>|值  |1   |5   |10  |50  |100 |500 |1000|</p>
<hr>
<hr>
<h1 id="第3章-数据存储"><a href="#第3章-数据存储" class="headerlink" title="第3章 数据存储"></a>第3章 数据存储</h1><h2 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h2><p>所有计算机外部的数据类型的数据都采用统一的数据表示法转换后存入计算机中，当数据从计算机输出时再还原回来。这种通用的格式称为<strong>位模式</strong>。</p>
<h4 id="1-位"><a href="#1-位" class="headerlink" title="1. 位"></a>1. 位</h4><p>位（bit，binary digit的缩写）是存储在计算机中的最小单位，它是0或1。位代表设备的某一状态，这些设备只能处于两种状态之一。</p>
<h4 id="2-位模式"><a href="#2-位模式" class="headerlink" title="2. 位模式"></a>2. 位模式</h4><p>位模式是一个序列，有时也称为位流。<br>下面为由16个位组成的位模式：</p>
<center><pre>1 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1</pre></center>

<p>通常长度为8的位模式被称为1个<strong>字节</strong>（byte）。</p>
<p>属于不同数据类型的数据可以以相同的模式存储于内存中。如果使用文本编辑器，键盘上的字符A可以以8位模式01000001存储；如果使用数学程序，同样的8位模式可以表示数字65；类似地，同样的位模式可表示部分图像、部分音频等等。计算机内存存储所有这些而无需辨别它们表示的是何种数据类型。</p>
<hr>
<h2 id="3-2-存储数字"><a href="#3-2-存储数字" class="headerlink" title="3.2 存储数字"></a>3.2 存储数字</h2><p>在存储到计算机内存中之前数字被转换为二进制系统。这有两个问题：<br>1）如何存储数字的符号；<br>2）如何显示十进制小数点。</p>
<p>对于小数点，计算机使用两种不同的表示方法：定点和浮点。第一种用于把数字作为整数存储，第二种把数字作为实数存储。</p>
<h3 id="3-2-1-存储整数"><a href="#3-2-1-存储整数" class="headerlink" title="3.2.1 存储整数"></a>3.2.1 存储整数</h3><p>整数通常使用定点表示法存储在内存中。</p>
<h4 id="1-无符号表示法"><a href="#1-无符号表示法" class="headerlink" title="1. 无符号表示法"></a>1. 无符号表示法</h4><p><strong>无符号整数</strong>就是没有符号的整数。<br>计算机都定义了一个最大无符号整数的常量，称为最大无符号整数，它的值是\(2^n－1\)。这里n就是计算机中分配用于表示无符号整数的二进制位数。</p>
<p>（1）存储无符号整数<br>首先将整数变成二进制数；<br>如果二进制位数不足n位，则在二进制整数的左边补0，使它的总位数为n位。如果位数大于n，该整数无法存储，导致<strong>溢出</strong>的情况发生。</p>
<p>（2）译解无符号整数<br>输出设备译解内存中位模式的位串并转换为一个十进制的无符号整数。</p>
<p>（3）溢出<br>因为大小（即存储单元的位的数量）的限制，可以表达的整数范围是有限的，在n位存储单元中，我们可以存储的无符号整数仅为\(0\)到\(2^n－1\)之间。</p>
<p>（4）无符号整数的应用<br>无符号整数表示法可以提高存储的效率，因为不必存储整数的符号，这就意味着所有分配的位单元都可以用来存储数字。只要用不到负整数，都可以用无符号整数表示法。</p>
<h4 id="2-符号加绝对值表示法"><a href="#2-符号加绝对值表示法" class="headerlink" title="2. 符号加绝对值表示法"></a>2. 符号加绝对值表示法</h4><p>该表示法用于在计算机中存储部分实数。<br>在这种方法中，勇于无符号整数的有效范围（0到2^n－1）被分成2个相等的子范围。前半个表示正整数，后半个表示负整数。<br><strong>注意：</strong> </p>
<blockquote>
<ol>
<li>负数出现在正数的右边；</li>
<li>该系统中有两个0：正0（0000）和负0（1000）。</li>
</ol>
</blockquote>
<pre>
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1011 1100 1101 1110 1111  
 0    1    2    3    4    5    6    7    -0   -1   -2   -3   -4   -5   -6
</pre>

<p>用符号加绝对值格式存储一个整数，需要用1个二进制位表示符号（0表示正，1表示负），这就意味着在一个8位存储单位中，可以仅用7位表示数字的绝对值。因此，最大的正数值仅是无符号最大数的一半。在n位但愿可存储的数字范围是\(-（2^{n-1}-1）\)至\(+（2^{n-1}-1）\)。</p>
<p><strong>在符号加绝对值格式表示法中，最左位用于定义整数的符号。0表示正整数，1表示负整数。</strong></p>
<p>符号加绝对值表示法不用于存储整数，而用于存储部分实数，通常也用于采样模拟信号（如音频等）。</p>
<h4 id="3-二进制补码表示法"><a href="#3-二进制补码表示法" class="headerlink" title="3. 二进制补码表示法"></a>3. 二进制补码表示法</h4><p>几乎所有等俄计算机都使用二进制补码表示法来存储位于n位存储单元中的有符号整数。<br>无符号整数的有效范围（\(0\)到\(2^n-1\)）被分为2个相等的子范围，第一个子范围用来表示非负整数，第二个子范围用来表示负整数。</p>
<pre>
1000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111
 -8   -7   -6   -5   -4   -3   -2   -1    0    1    2    3    4    5    6    7
</pre>

<p><strong>最左位决定符号，0表示正，1表示负。</strong></p>
<p>（1）两种运算</p>
<p>① <strong>反码</strong>：反转各个位，即把0位变成1位，把1位变成0位。<br>② <strong>补码</strong>：首先，从<strong>右边</strong>复制位，直到有1被复制；接着，反转其余的位。</p>
<p>（2）以二进制补码格式存储整数</p>
<blockquote>
<ol>
<li>将整数变成n位的二进制数；</li>
<li>如果整数是正数或零，以其原样存储；如果是负数，计算机取其补码存储。</li>
</ol>
</blockquote>
<p>（3）从二进制补码格式还原整数</p>
<blockquote>
<ol>
<li>如果最左位是1，计算机取其补码。如果最左位是0，计算机不进行操作。</li>
<li>计算机将该整数转换为十进制。</li>
</ol>
</blockquote>
<p>例子：用二进制补码表示法将整数-28存储在8位存储单元中。<br>该整数是负数，因此在转换成二进制后计算机对其进行二进制补码运算。</p>
<pre>
把28变为8位的二进制    0   0   0   1   1   1   0   0
                     ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
进行补码运算           1   1   1   0   0   1   0   0
</pre>

<p><strong>二进制补码表示法仅有一个0。</strong></p>
<p>（5）应用<br>二进制补码表示法是计算机中用于存储整数的标准表示法。</p>
<h4 id="4-3种系统的比较"><a href="#4-3种系统的比较" class="headerlink" title="4. 3种系统的比较"></a>4. 3种系统的比较</h4><table>
<thead>
<tr>
<th>存储单元的内容</th>
<th>无符号</th>
<th>符号加绝对值</th>
<th>二进制补码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0</td>
<td>0</td>
<td>+0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
<td>1</td>
<td>+1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
<td>2</td>
<td>+2</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
<td>3</td>
<td>+3</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
<td>4</td>
<td>+4</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
<td>5</td>
<td>+5</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
<td>6</td>
<td>+6</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
<td>7</td>
<td>+7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>-0</td>
<td>+8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>-1</td>
<td>-7</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>-2</td>
<td>-6</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>-3</td>
<td>-5</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>-4</td>
<td>-4</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>-5</td>
<td>-3</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>-6</td>
<td>-2</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>-7</td>
<td>-1</td>
</tr>
</tbody>
</table>
<h3 id="3-2-2-存储实数"><a href="#3-2-2-存储实数" class="headerlink" title="3.2.2 存储实数"></a>3.2.2 存储实数</h3><p>实数是带有整数部分和小数部分的数字。<br><strong>带有很大的整数部分或很小的小数部分的实数不应该用定点表示法存储。</strong></p>
<h4 id="1-浮点表示法"><a href="#1-浮点表示法" class="headerlink" title="1. 浮点表示法"></a>1. 浮点表示法</h4><p>浮点表示法允许小数点浮动，极大地增加了可存储的实数范围，带有很大的整数部分或很小的小数部分的实数可以存储在内存中。<br><strong>在浮点表示法中，无论十进制还是二进制，一个数字都由3部分组成：符号、位移量、定点数。</strong></p>
<center><code>符号</code> <code>位移量</code> <code>定点数</code></center>

<h4 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2. 规范化"></a>2. 规范化</h4><p>浮点表示法在小数点左边使用了唯一的非零数码。十进制系统中的数码可是1到9，二进制系统中该数码是1。</p>
<pre><code>十进制 →  d.xxxxxxxxxx  (1≤d≤9)
二进制 →  1.yyyyyyyyyy
</code></pre><h4 id="3-符号、指数和尾数"><a href="#3-符号、指数和尾数" class="headerlink" title="3. 符号、指数和尾数"></a>3. 符号、指数和尾数</h4><p>在一个二进制数规范化之后，只存储了该数的3部分信息符号、指数和尾数（小数点右边的位）。</p>
<blockquote>
<ul>
<li>符号：0表示正号，1表示符号；</li>
<li>指数：幂可正可负，<strong>余码表示法</strong>是用来存储指数位的方法；</li>
<li>尾数：小数点右边的二进制数，定义了该数的精度，是作为符号加绝对值格式的整数存储的。尾数的右边插入零，会改变该值。</li>
</ul>
</blockquote>
<p>例如，+1000111.0101规范化后变成：</p>
<pre><code>      +   2^6   ×   1.0001110101
      +    6          0001110101
      ↑    ↑              ↑
     符号 指数           尾数
</code></pre><p><strong>注意小数点和定点部分左边的位1并没有存储，它们是隐含的。</strong></p>
<h4 id="4-余码系统"><a href="#4-余码系统" class="headerlink" title="4. 余码系统"></a>4. 余码系统</h4><p>在该余码系统中，正的和负的整数都可以作为无符号数存储。<br>为了表示正的或负的整数，将正整数（成为一个<strong>偏移量</strong>）添加到每个数字中，将他们统一移到非负的一边。<br>这个偏移量的值是\(2^{m-1}-1\)，m是内存单元存储指数的大小。</p>
<h4 id="5-IEEE标准"><a href="#5-IEEE标准" class="headerlink" title="5. IEEE标准"></a>5. IEEE标准</h4><p>电气和电子工程师协会（IEEE）定义了几种存储浮点数的标准，最常用的两种：单精度、双精度。</p>
<p>单精度采用总共32位来存储一个浮点表示法的实数。<br>符号使用1位，指数使用8位（使用偏移量127），尾数使用23位（无符号数）。<br>该标准也称为<strong>余127码</strong>（Excess_127）：</p>
<pre><code>余127码    【符号】 【指数】 【尾数】
位数          1        8      23
</code></pre><p>双精度采用总共64位来存储一个浮点表示法的实数。<br>符号使用1位，指数使用11位（使用偏移量1023），尾数使用52位（无符号数）。<br>该标准也称为<strong>余1023码</strong>（Excess_1023）：</p>
<pre><code>余1023码   【符号】 【指数】 【尾数】
位数          1       11      52  
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>单精度</th>
<th>双精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存单元大小（位数）</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>符号大小（位数）</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>指数大小（位数）</td>
<td>8</td>
<td>11</td>
</tr>
<tr>
<td>尾数大小（位数）</td>
<td>23</td>
<td>52</td>
</tr>
<tr>
<td>偏移量（整数）</td>
<td>127</td>
<td>1023</td>
</tr>
</tbody>
</table>
<h4 id="6-IEEE标准浮点数的存储"><a href="#6-IEEE标准浮点数的存储" class="headerlink" title="6. IEEE标准浮点数的存储"></a>6. IEEE标准浮点数的存储</h4><blockquote>
<p>① 在S中存储符号；<br>② 将数字转换为二进制；<br>③ 规范化；<br>④ 找到E和M的值；<br>⑤ 连接S，E和M。</p>
</blockquote>
<p>例：写出十进制5.75的余127码（单精度）表示法。</p>
<blockquote>
<p>① 符号为正，S=0；</p>
<p>② 十进制转换为二进制：\(5.75=(101.11)_2\) ；</p>
<p>③ 规范化：\((101.11)_2=(1.1011)_2 \times 2^2\);</p>
<p>④ \(E=2+127+129=(10000001)_2\)，\(M=1011\)。需要在M的右边增加19个0使之成为23位。</p>
<p>⑤ 连接S、E、M，得\(01000000110110000000000000000000\)。</p>
</blockquote>
<h4 id="7-将存储为IEEE标准浮点格式的数字还原"><a href="#7-将存储为IEEE标准浮点格式的数字还原" class="headerlink" title="7. 将存储为IEEE标准浮点格式的数字还原"></a>7. 将存储为IEEE标准浮点格式的数字还原</h4><blockquote>
<p>① 找到S、E和M；<br>② S=0，符号为正号，否则为负号；<br>③ 找到位移量；<br>④ 对尾数去规范化；<br>⑤ 将去规范化的数字变为十进制以求出绝对值；<br>⑥ 加上符号。</p>
</blockquote>
<h4 id="8-存储零"><a href="#8-存储零" class="headerlink" title="8. 存储零"></a>8. 存储零</h4><p>规定存储零时，符号、指数和尾数都设为0。</p>
<h4 id="9-截断误差"><a href="#9-截断误差" class="headerlink" title="9. 截断误差"></a>9. 截断误差</h4><p>原始数字和还原后数字的差异称为<strong>截断误差</strong>。</p>
<hr>
<h2 id="3-3-存储文本"><a href="#3-3-存储文本" class="headerlink" title="3.3 存储文本"></a>3.3 存储文本</h2><p>在一种语言中，位模式需要多少位来表示一个符号，取决于该语言集里有多少不同的符号。<br>位模式的长度取决于符号的数量，它们的关系不是线性的，而是对数的关系。</p>
<table>
<thead>
<tr>
<th>位模式的长度</th>
<th>符号的数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>16</td>
</tr>
<tr>
<td>7</td>
<td>128</td>
</tr>
<tr>
<td>8</td>
<td>256</td>
</tr>
<tr>
<td>16</td>
<td>65536</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
</tr>
</tbody>
</table>
<p><strong>代码</strong>：不用的位模式集合被设计用于表示文本符号，每一个集合成为代码。<br><strong>编码</strong>：表示符号的过程称为编码。</p>
<blockquote>
<ul>
<li>ASCII：美国信息交换标准码，该代码使用7位表示符号。</li>
<li>Unicode：由硬件和软件制造商联合设计，使用32位表示符号。</li>
<li>其他编码。</li>
</ul>
</blockquote>
<hr>
<h2 id="3-4-存储音频"><a href="#3-4-存储音频" class="headerlink" title="3.4 存储音频"></a>3.4 存储音频</h2><p>音频是<strong>模拟</strong>数据，不可能将一段时间度量的而所有值存储到计算机中。</p>
<h3 id="3-4-1-采样"><a href="#3-4-1-采样" class="headerlink" title="3.4.1 采样"></a>3.4.1 采样</h3><p>采样指在模拟信号上选择数量有限的点来度量它们的值并记录下来。<br>采样率指每秒采取的样本数量。</p>
<h3 id="3-4-2-量化"><a href="#3-4-2-量化" class="headerlink" title="3.4.2 量化"></a>3.4.2 量化</h3><p>量化指将样本的值截取为最接近的整数值的一种过程。如实际值为17.2，就可截取为17。</p>
<h3 id="3-4-3-编码"><a href="#3-4-3-编码" class="headerlink" title="3.4.3 编码"></a>3.4.3 编码</h3><p>量化的样本值需要被编码成位模式。</p>
<h4 id="1-每样本位"><a href="#1-每样本位" class="headerlink" title="1. 每样本位"></a>1. 每样本位</h4><p>每个样本系统分配多少位。每样本位的数量也称为<strong>位深度</strong>。</p>
<h4 id="2-位率"><a href="#2-位率" class="headerlink" title="2. 位率"></a>2. 位率</h4><p>位深度或每样本位的数量为B，每秒样本数为S，则需要为每秒的音频存储S×B位，该乘积称为<strong>位率R</strong>。</p>
<h3 id="3-4-4-声音编码标准"><a href="#3-4-4-声音编码标准" class="headerlink" title="3.4.4 声音编码标准"></a>3.4.4 声音编码标准</h3><p>当前音频编码的主流标准式MP3（MPEG Layer 3的简写），每秒44100个样本以及每样本16位，信号达到705600b/s的位率。</p>
<hr>
<h2 id="3-5-存储图像"><a href="#3-5-存储图像" class="headerlink" title="3.5 存储图像"></a>3.5 存储图像</h2><h3 id="3-5-1-光栅图"><a href="#3-5-1-光栅图" class="headerlink" title="3.5.1 光栅图"></a>3.5.1 光栅图</h3><p>采样称为<strong>扫描</strong>；样本称为<strong>像素</strong>。</p>
<h4 id="1-解析度"><a href="#1-解析度" class="headerlink" title="1. 解析度"></a>1. 解析度</h4><p>在图像处理中，每英寸的方块或线条记录多少像素，扫描率称为<strong>解析度</strong>。</p>
<h4 id="2-色彩深度"><a href="#2-色彩深度" class="headerlink" title="2. 色彩深度"></a>2. 色彩深度</h4><p>色彩深度指用于表现像素的位的数量。</p>
<h3 id="3-5-2-矢量图"><a href="#3-5-2-矢量图" class="headerlink" title="3.5.2 矢量图"></a>3.5.2 矢量图</h3><p>矢量图图像编码方法并不存储每个像素的位模式，而是有绘制这些图像的形状的一系列命令构成的。<br>矢量图也称为<em>几何模型</em>或<em>面向对象图形</em>。</p>
<hr>
<hr>
<h1 id="第4章-数据运算"><a href="#第4章-数据运算" class="headerlink" title="第4章 数据运算"></a>第4章 数据运算</h1><h2 id="4-1-逻辑运算"><a href="#4-1-逻辑运算" class="headerlink" title="4.1 逻辑运算"></a>4.1 逻辑运算</h2><p><strong>逻辑运算</strong>是指那些应用于模式中的一个二进制位，或在两个模式中相应的两个二进制位的相同基本运算。</p>
<h3 id="4-1-1-位层次上的逻辑运算"><a href="#4-1-1-位层次上的逻辑运算" class="headerlink" title="4.1.1 位层次上的逻辑运算"></a>4.1.1 位层次上的逻辑运算</h3><p>布尔代数，逻辑的特殊数学领域。<br>4种用来操纵二进制位的位层次上的运算：非（NOT）、与（AND）、或（OR）、异或（XOR）。</p>
<h4 id="1-非（NOT）"><a href="#1-非（NOT）" class="headerlink" title="1. 非（NOT）"></a>1. 非（NOT）</h4><p>NOT运算符是一元运算符：只有一个输入。<br>|x|NOT x|<br>|:-:|:-:|<br>|0|1|<br>|1|0|</p>
<h4 id="2-与（AND）"><a href="#2-与（AND）" class="headerlink" title="2. 与（AND）"></a>2. 与（AND）</h4><p>AND运算符是二元运算符：有两个输出。<br>|x|y|x AND y|<br>|:-:|:-:|:-:|<br>|0|0|0|<br>|0|1|0|<br>|1|0|0|<br>|1|1|1|</p>
<p><strong>如果输入中有一位是0，则不需要检查其他输入的相应的位便可迅速得到结果为0。</strong></p>
<h4 id="3-或（OR）"><a href="#3-或（OR）" class="headerlink" title="3. 或（OR）"></a>3. 或（OR）</h4><p>OR运算符是二元运算符。<br>|x|y|x OR y|<br>|:-:|:-:|:-:|<br>|0|0|0|<br>|0|1|1|<br>|1|0|1|<br>|1|1|1|</p>
<p><strong>如果输入中有一位是1，则不需要检查其他输入的相应的位便可迅速得到结果为1。</strong></p>
<h4 id="4-异或（XOR）"><a href="#4-异或（XOR）" class="headerlink" title="4. 异或（XOR）"></a>4. 异或（XOR）</h4><p>XOR运算符是二元运算符。<br>|x|y|x XOR y|<br>|:-:|:-:|:-:|<br>|0|0|0|<br>|0|1|1|<br>|1|0|1|<br>|1|1|0|</p>
<p>当输入相同时，则输出为0；当输入不同时，则输出为1。</p>
<p><strong>如果输入中的一位是1，那结果就是与其他输入中相应位相反。</strong></p>
<h3 id="4-1-2-模式层次上的逻辑运算"><a href="#4-1-2-模式层次上的逻辑运算" class="headerlink" title="4.1.2 模式层次上的逻辑运算"></a>4.1.2 模式层次上的逻辑运算</h3><p>相同的4个运算符可以被应用到n位模式，效果就是对NOT运算来说，把每个运算符应用于每个位；对于其他3个运算符就是每个运算符应用于相应的位对。</p>
<h4 id="1-求反"><a href="#1-求反" class="headerlink" title="1. 求反"></a>1. 求反</h4><p>NOT运算符的唯一应用就是对整个模式求反。</p>
<p>####2. 使指定的位复位<br>AND运算符的一个应用是把一个位模式的指定位<strong>复位（置0）</strong>。这种情况下第二个输入称为<strong>掩码</strong>。<br>掩码中的0位对第一个输入中相应的位进行复位。掩码中的1位使得第一个输入中相应的位保持不变。</p>
<pre><code>        1 0 1 0 0 1 1 0   输入
AND     0 0 0 0 0 1 1 0   掩码
        0 0 0 0 0 1 1 0   输出
</code></pre><h4 id="3-对指定的位置位"><a href="#3-对指定的位置位" class="headerlink" title="3. 对指定的位置位"></a>3. 对指定的位置位</h4><p>OR运算的一个应用是吧一个位模式的指定位<strong>置位（置1）</strong>。<br>掩码中的1位对第一个输入中相应的位进行置位。掩码中的0位使得第一个输入中相应的位保持不变。</p>
<pre><code>        1 0 1 0 0 1 1 0   输入
OR      1 1 1 1 1 0 0 0   掩码
        1 1 1 1 1 1 1 0   输出
</code></pre><hr>
<h2 id="4-2-移位运算"><a href="#4-2-移位运算" class="headerlink" title="4.2 移位运算"></a>4.2 移位运算</h2><p>移位运算移动模式中的位，改变位的位置，可以向左或向右移动位。<br>移位运算分成两大类：逻辑移位运算、算术移位运算。</p>
<h3 id="4-2-1-逻辑移位运算"><a href="#4-2-1-逻辑移位运算" class="headerlink" title="4.2.1 逻辑移位运算"></a>4.2.1 逻辑移位运算</h3><p>逻辑移位运算应用于不带符号位的数的模式。原因是这些移位运算可能会改变数的符号。</p>
<h4 id="1-逻辑移位"><a href="#1-逻辑移位" class="headerlink" title="1. 逻辑移位"></a>1. 逻辑移位</h4><p><strong>逻辑右移运算</strong>把每一位向右移动一个位置。在n位模式中，最右边被丢弃，最左位填0。<br><strong>逻辑左移运算</strong>把每一位向左移动一个位置。在n位模式中，最左位被丢弃，最右位填0。</p>
<pre><code>逻辑右移     0→□□□□□□→丢弃
逻辑左移     丢弃←□□□□□□←0
</code></pre><h4 id="2-循环移位"><a href="#2-循环移位" class="headerlink" title="2. 循环移位"></a>2. 循环移位</h4><p><strong>循环移位运算（旋转运算）</strong>进行移位，没有位被丢弃或增加。<br>循环右移（或右旋转）把每一位向右移动一个位置，最右位被回环，成为最左位。<br>循环左移（或左旋转）把每一位向左移动一个位置，最左位被回环，成为最右位。</p>
<h3 id="4-2-2-算术移位运算"><a href="#4-2-2-算术移位运算" class="headerlink" title="4.2.2 算术移位运算"></a>4.2.2 算术移位运算</h3><p><strong>算术移位运算</strong>假定位模式是用二进制补码格式表示的带符号位的整数。<strong>算术右移被用来对整数除以2；而算术左移被用来对整数乘以2。</strong><br>算术右移保留符号位，但同时也把它复制，放入相邻的右边的位中，因此符号被保存。<br>算术左移丢弃符号位，接受它的右边的位作为符号位。如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的。</p>
<pre><code>算术右移     复制最左位→□□□□□□→丢弃
算术左移     丢弃←□□□□□□←0
</code></pre><hr>
<h2 id="4-3-算术运算"><a href="#4-3-算术运算" class="headerlink" title="4.3 算术运算"></a>4.3 算术运算</h2><p><strong>算术运算</strong>包括加、减、乘、除等，适用于整数和浮点数。</p>
<h3 id="4-3-1-整数的算术运算"><a href="#4-3-1-整数的算术运算" class="headerlink" title="4.3.1 整数的算术运算"></a>4.3.1 整数的算术运算</h3><h4 id="1-二进制补码整数的加减法"><a href="#1-二进制补码整数的加减法" class="headerlink" title="1. 二进制补码整数的加减法"></a>1. 二进制补码整数的加减法</h4><p>整数通常是以二进制补码形式存储的，它的一个优点是加法和减法之间没有区别。当遇到减法运算时，可转变为加法：<br>$$A-B \leftrightarrow A+( \bar{B}+1)$$<br>这里，\(\bar{B}\)表示\(B\)的反码， \(( \bar{B}+1)\)表示\(B\)的补码。</p>
<p>二进制补码中的加法就像十进制中的加法一样：列与列相加，如果有进位，就加到下一列上。<strong>但是，最后一列的进位被舍弃。</strong></p>
<p>例：以二进制补码格式存储两个整数A和B，显示如何从A中减去B。\(A=(00011000)_2，B=(11101111)_2\)。<br>A减去B相当于A加上B的补码：</p>
<pre><code>    0 0 0 1 1 0 0 0    A
+   0 0 0 1 0 0 0 1    B的补码
    0 0 1 0 1 0 0 1    结果
用十进制检查结果，（+24）-（-17）=（+41）
</code></pre><p><strong>当进行计算机数字中的算术运算时，要记住每个数字和结果应该在分配的二进制位的定义范围之内。</strong></p>
<h4 id="2-符号加绝对值整数的加减法"><a href="#2-符号加绝对值整数的加减法" class="headerlink" title="2. 符号加绝对值整数的加减法"></a>2. 符号加绝对值整数的加减法</h4><p>用符号加绝对值表示的整数的加法和减法比较复杂。</p>
<center>![QQ截图20160909143940.png-185.1kB][1]</center>

<h3 id="4-3-2-实数的算术运算"><a href="#4-3-2-实数的算术运算" class="headerlink" title="4.3.2 实数的算术运算"></a>4.3.2 实数的算术运算</h3><p>算术运算能应用于用浮点数格式存储的实数上。</p>
<h4 id="1-实数的加减法"><a href="#1-实数的加减法" class="headerlink" title="1. 实数的加减法"></a>1. 实数的加减法</h4><p>以浮点数格式存储的实数的加法和减法被简化为小数点对齐后以符号加绝对值格式（符号和尾数的组合）存储的两整数的加法和减法。</p>
<center>![QQ截图20160909145906.png-185.9kB][2]</center>

<p>例：显示计算机是如何计算结果的：(+5.75)+(+161.875)=(+167.625)<br>这两个数以浮点数格式存储的。<br>|数字|S|E|M|<br>|:-:|:-:|:-:|:-:|<br>|A|0|10000001|01110000000000000000000|<br>|B|0|10000110|01000011110000000000000|<br>给尾数增加隐含的1，增加指数进行去规范化。两个去规范化后的尾数都是24位，包含了隐含的1，他们应该被存储在有24位的存储单元中。每个指数都被增加了。<br>|数字|S|E|去规范化的M|<br>|:-:|:-:|:-:|:-:|<br>|A|0|10000010|101110000000000000000000|<br>|B|0|10000111|101000011110000000000000|<br>对齐尾数。把第一个指数改为$(10000111)_2$，所谓需要把尾数右移5位。<br>|数字|S|E|去规范化的M|<br>|:-:|:-:|:-:|:-:|<br>|A|0|10000111|000001011100000000000000|<br>|B|0|10000111|101000011110000000000000|<br>进行绝对值加法。<br>|数字|S|E|去规范化的M|<br>|:-:|:-:|:-:|:-:|<br>|R|0|10000111|101001111010000000000000|<br>规范化。<br>|数字|S|E|去规范化的M|<br>|:-:|:-:|:-:|:-:|<br>|R|0|10000110|01001111010000000000000|</p>

	</div>
	<div class="meta split">
		<time class="post-date" datetime="2016-11-12T15:20:24.000Z" itemprop="datePublished">2016-11-12</time>
	</div>
</article>

<!--评论-->

	
<div class="ds-thread" data-thread-key="计算机基础与数据存储、运算" data-title="计算机基础与数据存储、运算" data-url="http://yoursite.com/2016/11/12/计算机基础与数据存储、运算/"></div>
<script type="text/javascript">

var duoshuoQuery = {short_name:"DanielXH"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


  
</div>


  <svg id="bigTriangleColor" width="100%" height="40" viewBox="0 0 100 102" preserveAspectRatio="none">
    <path d="M0 0 L50 100 L100 0 Z"></path>
  </svg>

  


  <div class="wrapper"></div>





<div class="fat-footer">
	<div class="wrapper">
		<div class="layout layout--center">
			<div class="layout__item palm-mb">
				<div class="media">
					<img class="headimg" src='http://p1.bqimg.com/578584/84dfc09208d11ea0.jpg' alt='DanielXH'>
					<div class="media__body">
						<h4>DanielXH</h4>
						<p class='site-description'>等待更新中</p>
					</div>
				</div>
				<div class="author-contact">
					<ul>
						
							
							<li>
				        		<a href="javascript:;" target="_blank">
				        			
				        				<i class="iconfont icon-weibo"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="javascript:;" target="_blank">
				        			
				        				<i class="iconfont icon-github"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="javascript:;" target="_blank">
				        			
										<i class="iconfont icon-zhihu"></i>
				        			
				        		</a>
				        	</li>
						
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer" role="contentinfo">
	<div class="wrapper wrapper--wide split split--responsive">
		<span>Xudongh ❤ Personal website. Powered by <a href="http://hexo.io">Hexo</a></span>
	</div>
</footer>

	<!-－这里导入了 lib.js 里面涵盖了 jQuery 等框架 所以注释掉-->
	<!--<script src="http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js"></script>-->
	<script src="/js/lib.js"></script>
	<script src="/js/google-code-prettify/prettify.js"></script>
	<script src="/js/module.js"></script>
	<script src="/js/script.js"></script>
	<script type='text/javascript'>
		//代码高亮
		$(document).ready(function(){
	 		$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   			prettyPrint();
		});
	</script>
	</body>
</html>